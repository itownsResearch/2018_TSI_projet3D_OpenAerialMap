{"version":3,"sources":["../../../src/Core/Geographic/Coordinates.js"],"names":["ellipsoidSizes","crsToUnit","reasonnableEpsilonForUnit","assertCrsIsValid","crsIsGeographic","crsIsGeocentric","convertValueToUnit","THREE","defs","projectionCache","x","y","z","ellipsoid","UNIT","RADIAN","DEGREE","METER","_unitFromProj4Unit","projunit","undefined","crs","p","units","unit","_crsToUnitWithError","u","Error","_assertIsGeographic","_assertIsGeocentric","instanceProj4","crsIn","crsOut","_convert","coordsIn","newCrs","target","Coordinates","refUnit","_internalStorageUnit","set","degToRad","_values","radToDeg","copy","cartesian","cartographicToCartesian","geo","cartesianToCartographic","longitude","latitude","h","val0","val1","forward","as","coordsInInter","Math","clamp","unitIn","unitOut","value","Float64Array","coordinates","Object","defineProperty","configurable","get","_normal","computeGeodesicNormal","planarNormal","Vector3","coord","geodeticSurfaceNormalCartographic","geodeticSurfaceNormal","prototype","length","i","clone","r","call","src","altitude","setAltitude","xyz","v","fromArray","offsetInExtent","extent","dimension","abs","east","west","north","south","originX","originY","Vector2","C","EPSG_4326","args","EPSG_4326_Radians","result"],"mappings":"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","file":"Coordinates.js","sourcesContent":["/**\n * Generated On: 2015-10-5\n * Class: Coordinates\n * Description: CoordonnÃ©es cartographiques\n */\n\nimport * as THREE from 'three';\nimport proj4 from 'proj4';\nimport mE from '../Math/MathExtended';\nimport Ellipsoid from '../Math/Ellipsoid';\n\nproj4.defs('EPSG:4978', '+proj=geocent +datum=WGS84 +units=m +no_defs');\n// used in some protocol\nproj4.defs('CRS:84', proj4.defs('EPSG:4326'));\n\nconst projectionCache = {};\n\nexport function ellipsoidSizes() {\n    return {\n        x: 6378137,\n        y: 6378137,\n        z: 6356752.3142451793,\n    };\n}\n\nconst ellipsoid = new Ellipsoid(ellipsoidSizes());\n\nexport const UNIT = {\n    RADIAN: 0,\n    DEGREE: 1,\n    METER: 2,\n};\n\nfunction _unitFromProj4Unit(projunit) {\n    if (projunit === 'degrees') {\n        return UNIT.DEGREE;\n    } else if (projunit === 'm') {\n        return UNIT.METER;\n    } else if (projunit === 'radians') {\n        return UNIT.RADIAN;\n    } else {\n        return undefined;\n    }\n}\n\nexport function crsToUnit(crs) {\n    switch (crs) {\n        case 'EPSG:4326' : return UNIT.DEGREE;\n        case 'EPSG:4978' : return UNIT.METER;\n        default: {\n            const p = proj4.defs(crs);\n            if (!p) {\n                return undefined;\n            }\n            return _unitFromProj4Unit(p.units);\n        }\n    }\n}\n\nexport function reasonnableEpsilonForUnit(unit) {\n    switch (unit) {\n        case UNIT.RADIAN: return 0.00001;\n        case UNIT.DEGREE: return 0.01;\n        case UNIT.METER: return 0.001;\n        default:\n            return 0;\n    }\n}\n\nfunction _crsToUnitWithError(crs) {\n    const u = crsToUnit(crs);\n    if (crs === undefined || u === undefined) {\n        throw new Error(`Invalid crs paramater value '${crs}'`);\n    }\n    return u;\n}\n\nexport function assertCrsIsValid(crs) {\n    _crsToUnitWithError(crs);\n}\n\nexport function crsIsGeographic(crs) {\n    return (_crsToUnitWithError(crs) != UNIT.METER);\n}\n\nexport function crsIsGeocentric(crs) {\n    return (_crsToUnitWithError(crs) == UNIT.METER);\n}\n\nfunction _assertIsGeographic(crs) {\n    if (!crsIsGeographic(crs)) {\n        throw new Error(`Can't query crs ${crs} long/lat`);\n    }\n}\n\nfunction _assertIsGeocentric(crs) {\n    if (!crsIsGeocentric(crs)) {\n        throw new Error(`Can't query crs ${crs} x/y/z`);\n    }\n}\n\nfunction instanceProj4(crsIn, crsOut) {\n    if (projectionCache[crsIn]) {\n        const p = projectionCache[crsIn];\n        if (p[crsOut]) {\n            return p[crsOut];\n        }\n    } else {\n        projectionCache[crsIn] = {};\n    }\n    const p = proj4(crsIn, crsOut);\n    projectionCache[crsIn][crsOut] = p;\n    return p;\n}\n\n// Only support explicit conversions\nfunction _convert(coordsIn, newCrs, target) {\n    target = target || new Coordinates(newCrs, 0, 0);\n    if (newCrs === coordsIn.crs) {\n        const refUnit = crsToUnit(newCrs);\n        if (coordsIn._internalStorageUnit != refUnit) {\n            // custom internal unit\n            if (coordsIn._internalStorageUnit == UNIT.DEGREE && refUnit == UNIT.RADIAN) {\n                return target.set(\n                    newCrs,\n                    mE.degToRad(coordsIn._values[0]),\n                    mE.degToRad(coordsIn._values[1]),\n                    coordsIn._values[2]);\n            } else if (coordsIn._internalStorageUnit == UNIT.RADIAN && refUnit == UNIT.DEGREE) {\n                return target.set(\n                    newCrs,\n                    mE.radToDeg(coordsIn._values[0]),\n                    mE.radToDeg(coordsIn._values[1]),\n                    coordsIn._values[2]);\n            }\n        } else {\n            return target.copy(coordsIn);\n        }\n    } else {\n        if (coordsIn.crs === 'EPSG:4326' && newCrs === 'EPSG:4978') {\n            const cartesian = ellipsoid.cartographicToCartesian(coordsIn);\n            return target.set(newCrs, cartesian);\n        }\n\n        if (coordsIn.crs === 'EPSG:4978' && newCrs === 'EPSG:4326') {\n            const geo = ellipsoid.cartesianToCartographic({\n                x: coordsIn._values[0],\n                y: coordsIn._values[1],\n                z: coordsIn._values[2],\n            });\n            return target.set(newCrs, geo.longitude, geo.latitude, geo.h);\n        }\n\n        if (coordsIn.crs in proj4.defs && newCrs in proj4.defs) {\n            let val0 = coordsIn._values[0];\n            let val1 = coordsIn._values[1];\n\n            // Verify that coordinates are stored in reference unit.\n            const refUnit = crsToUnit(coordsIn.crs);\n            if (coordsIn._internalStorageUnit != coordsIn.crs) {\n                if (coordsIn._internalStorageUnit == UNIT.DEGREE && refUnit == UNIT.RADIAN) {\n                    val0 = coordsIn.longitude(UNIT.RADIAN);\n                    val1 = coordsIn.latitude(UNIT.RADIAN);\n                } else if (coordsIn._internalStorageUnit == UNIT.RADIAN && refUnit == UNIT.DEGREE) {\n                    val0 = coordsIn.longitude(UNIT.DEGREE);\n                    val1 = coordsIn.latitude(UNIT.DEGREE);\n                }\n            }\n\n            // there is a bug for converting anything from and to 4978 with proj4\n            // https://github.com/proj4js/proj4js/issues/195\n            // the workaround is to use an intermediate projection, like EPSG:4326\n            if (newCrs == 'EPSG:4978') {\n                const p = instanceProj4(coordsIn.crs, 'EPSG:4326').forward([val0, val1]);\n                target.set('EPSG:4326', p[0], p[1], coordsIn._values[2]);\n                return target.as('EPSG:4978');\n            } else if (coordsIn.crs === 'EPSG:4978') {\n                const coordsInInter = coordsIn.as('EPSG:4326');\n                const p = instanceProj4(coordsInInter.crs, newCrs).forward([coordsInInter._values[0], coordsInInter._values[1]]);\n                target.set(newCrs, p[0], p[1], coordsInInter._values[2]);\n                return target;\n            } else if (coordsIn.crs == 'EPSG:4326' && newCrs == 'EPSG:3857') {\n                val1 = THREE.Math.clamp(val1, -89.999999999, 89.999999999);\n                const p = instanceProj4(coordsIn.crs, newCrs).forward([val0, val1]);\n                return target.set(newCrs, p[0], p[1], coordsIn._values[2]);\n            } else {\n                // here is the normal case with proj4\n                const p = instanceProj4(coordsIn.crs, newCrs).forward([val0, val1]);\n                return target.set(newCrs, p[0], p[1], coordsIn._values[2]);\n            }\n        }\n\n        throw new Error(`Cannot convert from crs ${coordsIn.crs} (unit=${coordsIn._internalStorageUnit}) to ${newCrs}`);\n    }\n}\n\nexport function convertValueToUnit(unitIn, unitOut, value) {\n    if (unitOut == undefined || unitIn == unitOut) {\n        return value;\n    } else {\n        if (unitIn == UNIT.DEGREE && unitOut == UNIT.RADIAN) {\n            return mE.degToRad(value);\n        }\n        if (unitIn == UNIT.RADIAN && unitOut == UNIT.DEGREE) {\n            return mE.radToDeg(value);\n        }\n        throw new Error(`Cannot convert from unit ${unitIn} to ${unitOut}`);\n    }\n}\n\n/**\n * Build a Coordinates object, given a {@link http://inspire.ec.europa.eu/theme/rs|crs} and a number of coordinates value. Coordinates can be in geocentric system, geographic system or an instance of {@link https://threejs.org/docs/#api/math/Vector3|THREE.Vector3}.\n * If crs = 'EPSG:4326', coordinates must be in geographic system.\n * If crs = 'EPSG:4978', coordinates must be in geocentric system.\n * @constructor\n * @param       {string} crs - Geographic or Geocentric coordinates system.\n * @param       {number|THREE.Vector3} coordinates - The globe coordinates to aim to.\n * @param       {number} coordinates.longitude - Geographic Coordinate longitude\n * @param       {number} coordinates.latitude - Geographic Coordinate latitude\n * @param       {number} coordinates.altitude - Geographic Coordinate altiude\n * @param       {number} coordinates.x - Geocentric Coordinate X\n * @param       {number} coordinates.y - Geocentric Coordinate Y\n * @param       {number} coordinates.z - Geocentric Coordinate Z\n * @example\n * new Coordinates('EPSG:4978', 20885167, 849862, 23385912); //Geocentric coordinates\n * // or\n * new Coordinates('EPSG:4326', 2.33, 48.24, 24999549); //Geographic coordinates\n */\n\nfunction Coordinates(crs, ...coordinates) {\n    this._values = new Float64Array(3);\n    this.set(crs, ...coordinates);\n\n    Object.defineProperty(this, 'geodesicNormal',\n        {\n            configurable: true,\n            get: () => {\n                this._normal = this._normal || computeGeodesicNormal(this);\n                return this._normal;\n            },\n        });\n}\n\nconst planarNormal = new THREE.Vector3(0, 0, 1);\n\nfunction computeGeodesicNormal(coord) {\n    if (coord.crs == 'EPSG:4326') {\n        return ellipsoid.geodeticSurfaceNormalCartographic(coord);\n    }\n    // In globe mode (EPSG:4978), we compute the normal.\n    if (coord.crs == 'EPSG:4978') {\n        return ellipsoid.geodeticSurfaceNormal(coord);\n    }\n    // In planar mode, normal is the up vector.\n    return planarNormal;\n}\n\nCoordinates.prototype.set = function set(crs, ...coordinates) {\n    _crsToUnitWithError(crs);\n    this.crs = crs;\n\n    if (coordinates.length == 1 && coordinates[0] instanceof THREE.Vector3) {\n        this._values[0] = coordinates[0].x;\n        this._values[1] = coordinates[0].y;\n        this._values[2] = coordinates[0].z;\n    } else {\n        for (let i = 0; i < coordinates.length && i < 3; i++) {\n            this._values[i] = coordinates[i];\n        }\n        for (let i = coordinates.length; i < 3; i++) {\n            this._values[i] = 0;\n        }\n    }\n    this._internalStorageUnit = crsToUnit(crs);\n    return this;\n};\n\nCoordinates.prototype.clone = function clone(target) {\n    let r;\n    if (target) {\n        Coordinates.call(target, this.crs, ...this._values);\n        r = target;\n    } else {\n        r = new Coordinates(this.crs, ...this._values);\n    }\n    r._internalStorageUnit = this._internalStorageUnit;\n    return r;\n};\n\nCoordinates.prototype.copy = function copy(src) {\n    this.set(src.crs, ...src._values);\n    this._internalStorageUnit = src._internalStorageUnit;\n    return this;\n};\n\n/**\n * Returns the longitude in geographic coordinates. Coordinates must be in geographic system (can be converted by using {@linkcode as()} ).\n * @example\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coordinates = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * coordinates.longitude(); // Longitude in geographic system\n * // returns 2.33\n *\n * // or\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * const coordinates = coords.as('EPSG:4326');  // Geographic system\n * coordinates.longitude(); // Longitude in geographic system\n * // returns 2.330201911389028\n *\n * @param      {number} [unit] - 0: Radians, 1: Degrees.\n * @return     {number} - The longitude of the position.\n */\n\nCoordinates.prototype.longitude = function longitude(unit) {\n    _assertIsGeographic(this.crs);\n    return convertValueToUnit(this._internalStorageUnit, unit, this._values[0]);\n};\n\n/**\n * Returns the latitude in geographic coordinates. Coordinates must be in geographic system (can be converted by using {@linkcode as()} ).\n * @example\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coordinates = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * coordinates.latitude(); // Latitude in geographic system\n * // returns : 48.24\n *\n * // or\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * const coordinates = coords.as('EPSG:4326');  // Geographic system\n * coordinates.latitude(); // Latitude in geographic system\n * // returns : 48.24830764643365\n *\n * @param      {number} [unit] - 0: Radians, 1: Degrees.\n * @return     {number} - The latitude of the position.\n */\n\nCoordinates.prototype.latitude = function latitude(unit) {\n    _assertIsGeographic(this.crs);\n    return convertValueToUnit(this._internalStorageUnit, unit, this._values[1]);\n};\n\n/**\n * Returns the altitude in geographic coordinates. Coordinates must be in geographic system (can be converted by using {@linkcode as()} ).\n * @example\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coordinates = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * coordinates.altitude(); // Altitude in geographic system\n * // returns : 24999549\n *\n * // or\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * const coordinates = coords.as('EPSG:4326');  // Geographic system\n * coordinates.altitude(); // Altitude in geographic system\n * // returns : 24999548.046711832\n *\n * @return     {number} - The altitude of the position.\n */\n\nCoordinates.prototype.altitude = function altitude() {\n    _assertIsGeographic(this.crs);\n    return this._values[2];\n};\n\n/**\n * Set the altiude.\n * @example coordinates.setAltitude(number)\n * @param      {number} - Set the altitude.\n */\n\nCoordinates.prototype.setAltitude = function setAltitude(altitude) {\n    _assertIsGeographic(this.crs);\n    this._values[2] = altitude;\n};\n\n /**\n * Returns the longitude in geocentric coordinates. Coordinates must be in geocentric system (can be converted by using {@linkcode as()} ).\n * @example\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * coordinates.x();  // Geocentric system\n * // returns : 20885167\n *\n * // or\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coords = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * const coordinates = coords.as('EPSG:4978'); // Geocentric system\n * coordinates.x(); // Geocentric system\n * // returns : 20888561.0301258\n *\n * @return     {number} - The longitude of the position.\n */\n\nCoordinates.prototype.x = function x() {\n    _assertIsGeocentric(this.crs);\n    return this._values[0];\n};\n\n/**\n * Returns the latitude in geocentric coordinates. Coordinates must be in geocentric system (can be converted by using {@linkcode as()} ).\n * @example\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * coordinates.y();  // Geocentric system\n * // returns : 849862\n *\n * // or\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coords = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * const coordinates = coords.as('EPSG:4978'); // Geocentric system\n * coordinates.y(); // Geocentric system\n * // returns : 849926.376770819\n *\n * @return     {number} - The latitude of the position.\n */\n\nCoordinates.prototype.y = function y() {\n    _assertIsGeocentric(this.crs);\n    return this._values[1];\n};\n\n/**\n * Returns the altitude in geocentric coordinates. Coordinates must be in geocentric system (can be converted by using {@linkcode as()} ).\n * @example\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * coordinates.z();  // Geocentric system\n * // returns : 23385912\n *\n * // or\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coords = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * const coordinates = coords.as('EPSG:4978'); // Geocentric system\n * coordinates.z(); // Geocentric system\n * // returns : 23382883.536591515\n *\n * @return     {number} - The altitude of the position.\n */\n\nCoordinates.prototype.z = function z() {\n    _assertIsGeocentric(this.crs);\n    return this._values[2];\n};\n\n/**\n * Returns a position in cartesian coordinates. Coordinates must be in geocentric system (can be converted by using {@linkcode as()} ).\n * @example\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coordinates = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * coordinates.xyz();  // Geocentric system\n * // returns : Vector3\n * // x: 20885167\n * // y: 849862\n * // z: 23385912\n *\n * // or\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coords = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * const coordinates = coords.as('EPSG:4978'); // Geocentric system\n * coordinates.xyz(); // Geocentric system\n * // returns : Vector3\n * // x: 20885167\n * // y: 849862\n * // z: 23385912\n *\n * @return     {Position} - position\n */\n\nCoordinates.prototype.xyz = function xyz(target) {\n    _assertIsGeocentric(this.crs);\n    const v = target || new THREE.Vector3();\n    v.fromArray(this._values);\n    return v;\n};\n\n/**\n * Returns coordinates in the wanted {@link http://inspire.ec.europa.eu/theme/rs|CRS}.\n * @example\n *\n * const position = { longitude: 2.33, latitude: 48.24, altitude: 24999549 };\n * const coords = new Coordinates('EPSG:4326', position.longitude, position.latitude, position.altitude); // Geographic system\n * const coordinates = coords.as('EPSG:4978'); // Geocentric system\n *\n * // or\n *\n * const position = { x: 20885167, y: 849862, z: 23385912 };\n * const coords = new Coordinates('EPSG:4978', position.x, position.y, position.z);  // Geocentric system\n * const coordinates = coords.as('EPSG:4326');  // Geographic system\n *\n * //or\n *\n * new Coordinates('EPSG:4326', longitude: 2.33, latitude: 48.24, altitude: 24999549).as('EPSG:4978'); // Geocentric system\n *\n * // or\n *\n * new Coordinates('EPSG:4978', x: 20885167, y: 849862, z: 23385912).as('EPSG:4326'); // Geographic system\n *\n * @param      {string} - {@link http://inspire.ec.europa.eu/theme/rs|crs} : Geocentric (ex: 'EPSG:4326') or Geographic (ex: 'EPSG:4978').\n * @return     {Position} - position\n */\n\nCoordinates.prototype.as = function as(crs, target) {\n    if (crs === undefined || !crsToUnit(crs)) {\n        throw new Error(`Invalid crs paramater value '${crs}'`);\n    }\n    return _convert(this, crs, target);\n};\n\n/**\n * Returns the normalized offset from top-left in extent of this Coordinates\n * e.g: extent.center().offsetInExtent(extent) would return (0.5, 0.5).\n * @param {Extent} extent\n * @param {Vector2} target optional Vector2 target. If not present a new one will be created\n * @return {Vector2} normalized offset in extent\n */\nCoordinates.prototype.offsetInExtent = function offsetInExtent(extent, target) {\n    if (this.crs != extent.crs()) {\n        throw new Error('unsupported mix');\n    }\n\n    const dimension = {\n        x: Math.abs(extent.east() - extent.west()),\n        y: Math.abs(extent.north() - extent.south()),\n    };\n\n    const x = extent._internalStorageUnit == UNIT.METER ? this.x() : this.longitude(extent._internalStorageUnit);\n    const y = extent._internalStorageUnit == UNIT.METER ? this.y() : this.latitude(extent._internalStorageUnit);\n\n    const originX = (x - extent.west()) / dimension.x;\n    const originY = (extent.north() - y) / dimension.y;\n\n    target = target || new THREE.Vector2();\n    target.set(originX, originY);\n    return target;\n};\n\nexport const C = {\n\n    /**\n     * Return a Coordinates object from a position object. The object just\n     * needs to have x, y, z properties.\n     *\n     * @param {string} crs - The crs of the original position\n     * @param {Object} position - the position to transform\n     * @param {number} position.x - the x component of the position\n     * @param {number} position.y - the y component of the position\n     * @param {number} position.z - the z component of the position\n     * @return {Coordinates}\n     */\n    EPSG_4326: function EPSG_4326(...args) {\n        return new Coordinates('EPSG:4326', ...args);\n    },\n    EPSG_4326_Radians: function EPSG_4326(...args) {\n        const result = new Coordinates('EPSG:4326', ...args);\n        result._internalStorageUnit = UNIT.RADIAN;\n        return result;\n    },\n};\n\nexport default Coordinates;\n"]}